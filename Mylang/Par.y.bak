-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Mylang.Par
  ( happyError
  , myLexer
  , pProgram
  , pVariable
  , pAssignOp
  , pType
  , pStandardType
  , pStatement
  , pExpression
  , pTerm
  , pFactor
  , pProcedureStatement
  , pExpressionList
  , pCompoundStatement
  , pStatementList
  , pReadStatement
  , pWriteStatement
  ) where

import Prelude

import qualified Mylang.Abs
import Mylang.Lex

}

%name pProgram Program
%name pVariable Variable
%name pAssignOp AssignOp
%name pType Type
%name pStandardType StandardType
%name pStatement Statement
%name pExpression Expression
%name pTerm Term
%name pFactor Factor
%name pProcedureStatement ProcedureStatement
%name pExpressionList ExpressionList
%name pCompoundStatement CompoundStatement
%name pStatementList StatementList
%name pReadStatement ReadStatement
%name pWriteStatement WriteStatement
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '('         { PT _ (TS _ 1)         }
  ')'         { PT _ (TS _ 2)         }
  '*'         { PT _ (TS _ 3)         }
  '+'         { PT _ (TS _ 4)         }
  ','         { PT _ (TS _ 5)         }
  '-'         { PT _ (TS _ 6)         }
  '/'         { PT _ (TS _ 7)         }
  ';'         { PT _ (TS _ 8)         }
  '='         { PT _ (TS _ 9)         }
  '['         { PT _ (TS _ 10)        }
  ']'         { PT _ (TS _ 11)        }
  'array'     { PT _ (TS _ 12)        }
  'begin'     { PT _ (TS _ 13)        }
  'do'        { PT _ (TS _ 14)        }
  'else'      { PT _ (TS _ 15)        }
  'end'       { PT _ (TS _ 16)        }
  'if'        { PT _ (TS _ 17)        }
  'integer'   { PT _ (TS _ 18)        }
  'program'   { PT _ (TS _ 19)        }
  'read'      { PT _ (TS _ 20)        }
  'then'      { PT _ (TS _ 21)        }
  'while'     { PT _ (TS _ 22)        }
  'write'     { PT _ (TS _ 23)        }
  L_Id        { PT _ (T_Id $$)        }
  L_MyInteger { PT _ (T_MyInteger $$) }
  L_MyString  { PT _ (T_MyString $$)  }

%%

Id :: { Mylang.Abs.Id }
Id  : L_Id { Mylang.Abs.Id $1 }

MyInteger :: { Mylang.Abs.MyInteger }
MyInteger  : L_MyInteger { Mylang.Abs.MyInteger $1 }

MyString :: { Mylang.Abs.MyString }
MyString  : L_MyString { Mylang.Abs.MyString $1 }

Program :: { Mylang.Abs.Program }
Program : 'program' Id { Mylang.Abs.Prog $2 }

Variable :: { Mylang.Abs.Variable }
Variable : Id { Mylang.Abs.Var $1 }

AssignOp :: { Mylang.Abs.AssignOp }
AssignOp : '=' { Mylang.Abs.AssignmentOp }

Type :: { Mylang.Abs.Type }
Type
  : StandardType { Mylang.Abs.Type $1 }
  | 'array' '[' MyInteger ']' { Mylang.Abs.ArrayType $3 }

StandardType :: { Mylang.Abs.StandardType }
StandardType : 'integer' { Mylang.Abs.StdType }

Statement :: { Mylang.Abs.Statement }
Statement
  : Variable AssignOp Expression { Mylang.Abs.AssignStmt $1 $2 $3 }
  | ProcedureStatement { Mylang.Abs.ProcStmt $1 }
  | CompoundStatement { Mylang.Abs.CompStmt $1 }
  | 'if' Expression 'then' Statement 'else' Statement { Mylang.Abs.IfThenElseStmt $2 $4 $6 }
  | 'if' Expression 'then' Statement { Mylang.Abs.IfThenStmt $2 $4 }
  | 'while' Expression 'do' Statement { Mylang.Abs.WhileDoStmt $2 $4 }
  | ReadStatement { Mylang.Abs.ReadStmt $1 }
  | WriteStatement { Mylang.Abs.WriteStmt $1 }

Expression :: { Mylang.Abs.Expression }
Expression
  : Expression '+' Term { Mylang.Abs.EAdd $1 $3 }
  | Expression '-' Term { Mylang.Abs.ESub $1 $3 }
  | Term { Mylang.Abs.ETerm $1 }

Term :: { Mylang.Abs.Term }
Term
  : Term '*' Factor { Mylang.Abs.EMul $1 $3 }
  | Term '/' Factor { Mylang.Abs.EDiv $1 $3 }
  | Factor { Mylang.Abs.ETermF $1 }

Factor :: { Mylang.Abs.Factor }
Factor
  : MyInteger { Mylang.Abs.EInt $1 }
  | Variable { Mylang.Abs.EVar $1 }
  | '(' Expression ')' { Mylang.Abs.EParen $2 }

ProcedureStatement :: { Mylang.Abs.ProcedureStatement }
ProcedureStatement
  : Id '(' ')' { Mylang.Abs.ProcNoArgs $1 }
  | Id '(' ExpressionList ')' { Mylang.Abs.ProcWithArgs $1 $3 }

ExpressionList :: { Mylang.Abs.ExpressionList }
ExpressionList
  : Expression { Mylang.Abs.ListExp $1 }
  | Expression ',' ExpressionList { Mylang.Abs.ListExpCons $1 $3 }

CompoundStatement :: { Mylang.Abs.CompoundStatement }
CompoundStatement
  : 'begin' StatementList 'end' { Mylang.Abs.CompSt $2 }

StatementList :: { Mylang.Abs.StatementList }
StatementList
  : Statement { Mylang.Abs.ListStmt $1 }
  | Statement ';' StatementList { Mylang.Abs.ListStmtCons $1 $3 }

ReadStatement :: { Mylang.Abs.ReadStatement }
ReadStatement : 'read' '(' Variable ')' { Mylang.Abs.ReadSt $3 }

WriteStatement :: { Mylang.Abs.WriteStatement }
WriteStatement
  : 'write' '(' Expression ')' { Mylang.Abs.WriteSt $3 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

