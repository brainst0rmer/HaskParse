-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Mylang.Par
  ( happyError
  , myLexer
  , pProgram
  , pVariable
  , pAssignOp
  , pType
  , pStandardType
  , pStatement
  , pExpression
  , pTerm
  , pFactor
  , pProcedureStatement
  , pExpressionList
  , pCompoundStatement
  , pStatementList
  , pReadStatement
  , pWriteStatement
  ) where

import Prelude

import qualified Mylang.Abs
import Mylang.Lex

}

%name pProgram Program
%name pVariable Variable
%name pAssignOp AssignOp
%name pType Type
%name pStandardType StandardType
%name pStatement Statement
%name pExpression Expression
%name pTerm Term
%name pFactor Factor
%name pProcedureStatement ProcedureStatement
%name pExpressionList ExpressionList
%name pCompoundStatement CompoundStatement
%name pStatementList StatementList
%name pReadStatement ReadStatement
%name pWriteStatement WriteStatement
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '('      { PT _ (TS _ 1)  }
  ')'      { PT _ (TS _ 2)  }
  '*'      { PT _ (TS _ 3)  }
  '+'      { PT _ (TS _ 4)  }
  ','      { PT _ (TS _ 5)  }
  '-'      { PT _ (TS _ 6)  }
  '/'      { PT _ (TS _ 7)  }
  ';'      { PT _ (TS _ 8)  }
  '='      { PT _ (TS _ 9)  }
  '['      { PT _ (TS _ 10) }
  ']'      { PT _ (TS _ 11) }
  'array'  { PT _ (TS _ 12) }
  'begin'  { PT _ (TS _ 13) }
  'do'     { PT _ (TS _ 14) }
  'else'   { PT _ (TS _ 15) }
  'end'    { PT _ (TS _ 16) }
  'if'     { PT _ (TS _ 17) }
  'read'   { PT _ (TS _ 18) }
  'then'   { PT _ (TS _ 19) }
  'while'  { PT _ (TS _ 20) }
  'write'  { PT _ (TS _ 21) }
  L_integ  { PT _ (TI $$)   }
  L_Id     { PT _ (T_Id $$) }
  L_integ  { PT _ (TI $$)   }
  L_quoted { PT _ (TL $$)   }

%%

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

Id :: { Mylang.Abs.Id }
Id  : L_Id { Mylang.Abs.Id $1 }

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

String  :: { String }
String   : L_quoted { $1 }

Program :: { Mylang.Abs.Program }
Program : Program Id { Mylang.Abs.Prog $1 $2 }

Variable :: { Mylang.Abs.Variable }
Variable : Id { Mylang.Abs.Var $1 }

AssignOp :: { Mylang.Abs.AssignOp }
AssignOp : '=' { Mylang.Abs.AssignOp }

Type :: { Mylang.Abs.Type }
Type
  : StandardType { Mylang.Abs.Type $1 }
  | 'array' '[' Integer ']' { Mylang.Abs.ArrayType $3 }

StandardType :: { Mylang.Abs.StandardType }
StandardType : Integer { Mylang.Abs.StdType $1 }

Statement :: { Mylang.Abs.Statement }
Statement
  : Variable AssignOp Expression { Mylang.Abs.AssignStmt $1 $2 $3 }
  | ProcedureStatement { Mylang.Abs.ProcStmt $1 }
  | CompoundStatement { Mylang.Abs.CompStmt $1 }
  | 'if' Expression 'then' Statement 'else' Statement { Mylang.Abs.IfThenElseStmt $2 $4 $6 }
  | 'if' Expression 'then' Statement { Mylang.Abs.IfThenStmt $2 $4 }
  | 'while' Expression 'do' Statement { Mylang.Abs.WhileDoStmt $2 $4 }
  | ReadStatement { Mylang.Abs.ReadStmt $1 }
  | WriteStatement { Mylang.Abs.WriteStmt $1 }

Expression :: { Mylang.Abs.Expression }
Expression
  : Expression '+' Term { Mylang.Abs.EAdd $1 $3 }
  | Expression '-' Term { Mylang.Abs.ESub $1 $3 }
  | Term { Mylang.Abs.ETerm $1 }

Term :: { Mylang.Abs.Term }
Term
  : Term '*' Factor { Mylang.Abs.EMul $1 $3 }
  | Term '/' Factor { Mylang.Abs.EDiv $1 $3 }
  | Factor { Mylang.Abs.ETermF $1 }

Factor :: { Mylang.Abs.Factor }
Factor
  : Integer { Mylang.Abs.EInt $1 }
  | Variable { Mylang.Abs.EVar $1 }
  | '(' Expression ')' { Mylang.Abs.EParen $2 }

ProcedureStatement :: { Mylang.Abs.ProcedureStatement }
ProcedureStatement
  : Id '(' ')' { Mylang.Abs.ProcNoArgs $1 }
  | Id '(' ExpressionList ')' { Mylang.Abs.ProcWithArgs $1 $3 }

ExpressionList :: { Mylang.Abs.ExpressionList }
ExpressionList
  : Expression { Mylang.Abs.ListExp $1 }
  | Expression ',' ExpressionList { Mylang.Abs.ListExpCons $1 $3 }

CompoundStatement :: { Mylang.Abs.CompoundStatement }
CompoundStatement
  : 'begin' StatementList 'end' { Mylang.Abs.CompSt $2 }

StatementList :: { Mylang.Abs.StatementList }
StatementList
  : Statement { Mylang.Abs.ListStmt $1 }
  | Statement ';' StatementList { Mylang.Abs.ListStmtCons $1 $3 }

ReadStatement :: { Mylang.Abs.ReadStatement }
ReadStatement : 'read' '(' Variable ')' { Mylang.Abs.ReadSt $3 }

WriteStatement :: { Mylang.Abs.WriteStatement }
WriteStatement
  : 'write' '(' Expression ')' { Mylang.Abs.WriteSt $3 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

